//
//  LogsWorker.swift
//  IteoLogger
//
//  Created by Patryk Średziński on 05/02/2021.
//  Copyright (c) 2021 iteo. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates by Patryk Średziński
//

import Foundation

enum LogsWorkerErrors: Error {
    case stringToDataFailed
}

protocol LogsWorker {
    
    var availableModules: Set<IteoLoggerModule> { get }
    var availableLevels: Set<IteoLoggerLevel> { get }

    func loadedSessionsCount() -> Int
    func loadLogs(at index: Int, filter: LogFilter) -> [IteoLoggerItem]
    func deleteLogs()
    func prepareShareString(sessions: [LogSectionItem]) -> String
    
}

final class LogsWorkerImpl {
    
    private let logsDirectoryName: String
    private let shareFormat: String
    private let jsonDecoder: JSONDecoder
    private let fileManager: FileManager
    private let dateFormatter = DateFormatManager.shared
    private let byteFormatter: ByteCountFormatter
    
    private var availableSessionPaths: [String]?
    private(set) var availableModules = Set<IteoLoggerModule>()
    private(set) var availableLevels = Set<IteoLoggerLevel>()

    init(logsDirectoryName: String,
         shareFormat: String,
         jsonDecoder: JSONDecoder = JSONDecoder(),
         fileManager: FileManager = FileManager.default,
         byteFormatter: ByteCountFormatter = ByteCountFormatter()) {
        self.logsDirectoryName = logsDirectoryName
        self.shareFormat = shareFormat
        self.jsonDecoder = jsonDecoder
        self.fileManager = fileManager
        self.byteFormatter = byteFormatter
    }
    
}

extension LogsWorkerImpl: LogsWorker {
    
    func loadedSessionsCount() -> Int {
        return (availableSessionPaths ?? []).count
    }
    
    func loadLogs(at index: Int, filter: LogFilter) -> [IteoLoggerItem] {
        let sessionPaths = availableSessionPaths ?? loadAvailableSessions()
        guard index < sessionPaths.count else { return [] }
        let logs = loadLogFile(at: sessionPaths[index])
        updateAvailableFilterData(for: logs, filter: filter)
        return logs.filter { filter.match($0) }
    }
    
    func deleteLogs() {
        deleteLogDirectory()
        availableSessionPaths = nil
    }
    
    func prepareShareString(sessions: [LogSectionItem]) -> String {
        var logString = ""
        sessions.forEach { sessionItem in
            logString += "\n"
            logString += "SESSION #\(sessionItem.index) - \(sessionItem.date)"
            logString += "\n"
            sessionItem.items.forEach { cellItem in
                if case .log(let item) = cellItem {
                    logString += item.toString(shareFormat, dateFormatter: DateFormatManager.shared)
                    logString += "\n"
                }
            }
        }
        let logSize = Int64(logString.data(using: .utf8)?.count ?? 0)
        let dateString = dateFormatter.string(from: Date(), format: .fullDate)
        let byteString = byteFormatter.string(fromByteCount: logSize)
        logString = "Logs generated at \(dateString), \(sessions.count) sessions, size: \(byteString)\n\(logString)"
        return logString
    }
}

private extension LogsWorkerImpl {
    
    private func loadAvailableSessions() -> [String] {
        do {
            availableSessionPaths = try loadAvailableSessionsPaths()
        } catch {
            availableSessionPaths = []
            assertionFailure(error.localizedDescription)
        }
        return availableSessionPaths ?? []
    }
    
    private func loadAvailableSessionsPaths() throws -> [String] {
        
        let logsDirectoryUrl = try fileManager.getLogsUrl(logsDirectoryName)
        let files = try fileManager.contentsOfDirectory(atPath: logsDirectoryUrl.path)
        return files.sorted().reversed()
        
    }
    
    private func loadLogFile(at path: String) -> [IteoLoggerItem] {
        do {
            let logsDirectoryUrl = try fileManager.getLogsUrl(logsDirectoryName)
            
            let logUrl = logsDirectoryUrl.appendingPathComponent(path)
            let logContent = try String(contentsOf: logUrl)
            let jsonLog = "[\(logContent)]"
            
            guard let jsonData = jsonLog.data(using: .utf8) else {
                throw LogsWorkerErrors.stringToDataFailed
            }
            
            let logItems = try jsonDecoder.decode([IteoLoggerItem].self, from: jsonData)
            return logItems.reversed()
        } catch {
            assertionFailure(error.localizedDescription)
            return []
        }
        
    }
    
    private func deleteLogDirectory() {
        do {
            let logsDirectoryUrl = try fileManager.getLogsUrl(logsDirectoryName)
            try fileManager.removeItem(at: logsDirectoryUrl)
        } catch {
            assertionFailure(error.localizedDescription)
        }
    }
    
    private func updateAvailableFilterData(for logs: [IteoLoggerItem], filter: LogFilter) {
        let uniqueLevels = Set(logs.map { $0.level })
        uniqueLevels.forEach {
            availableLevels.insert($0)
        }
        let uniqueModules = Set(logs.map { $0.module })
        uniqueModules.forEach {
            availableModules.insert($0)
        }
    }

}
